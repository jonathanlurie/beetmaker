{"version":3,"file":"beetmaker.js","sources":["../src/Track.js","../src/TrackCollection.js","../src/index.js"],"sourcesContent":["class Track {\n\n  constructor(name, decodedBuffer, audioContext){\n    this._name = name\n    this._decodedBuffer = decodedBuffer\n    this._audioContext = audioContext\n  }\n\n  // act as a factory; because sources can only be played once\n  createSource(connectToDestination = true){\n    let source = this._audioContext.createBufferSource()\n    source.buffer = this._decodedBuffer\n\n    // connect the AudioBufferSourceNode to the\n    // destination so we can hear the sound\n    if(connectToDestination){\n      source.connect(this._audioContext.destination)\n    }\n    return source\n  }\n\n\n  getDuration(){\n    return this._decodedBuffer.duration\n  }\n\n\n  getNumberOfChannels(){\n    return this._decodedBuffer.numberOfChannels()\n  }\n\n\n  getSampleRate(){\n    return this._decodedBuffer.sampleRate\n  }\n\n\n  play(){\n    let source = this.createSource(true)\n    source.start(0, /*offsetSecond, durationSecond*/)\n  }\n\n}\n\nexport default Track\n","import Track from './Track'\n\nclass TrackCollection {\n\n  constructor(audioContext=null){\n    if(!audioContext){\n      this._audioContext = new AudioContext()\n    } else {\n      this._audioContext = audioContext\n    }\n\n    this._collection = {}\n  }\n\n\n  addFromFile(file, name=null){\n    let effectiveName = name ? name : file.name\n    let that = this\n    let fileReader = new FileReader()\n\n    fileReader.onload = function(e){\n      that._audioContext.decodeAudioData(e.target.result,\n\n        // success callback\n        function(decodedAudioBuffer) {\n          that._addTrack(decodedAudioBuffer, effectiveName, that._audioContext)\n        },\n\n        // error callback\n        function(e){\n          console.log(\"Error with decoding audio data\" + e.err)\n        })\n    }\n    fileReader.readAsArrayBuffer(file)\n  }\n\n\n  _addTrack(decodedAudioBuffer, name, audioContext){\n    if(name in this._collection){\n      throw new Error(`A track named ${name} already exists.`)\n    }\n\n    this._collection[name] = new Track(name, decodedAudioBuffer, audioContext)\n  }\n\n}\n\nexport default TrackCollection\n","import TrackCollection from './TrackCollection'\n\nexport default ({\n  TrackCollection,\n})\n"],"names":[],"mappings":"AAAA,MAAM,KAAK,CAAC;;EAEV,WAAW,CAAC,IAAI,EAAE,aAAa,EAAE,YAAY,CAAC;IAC5C,IAAI,CAAC,KAAK,GAAG,KAAI;IACjB,IAAI,CAAC,cAAc,GAAG,cAAa;IACnC,IAAI,CAAC,aAAa,GAAG,aAAY;GAClC;;;EAGD,YAAY,CAAC,oBAAoB,GAAG,IAAI,CAAC;IACvC,IAAI,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,kBAAkB,GAAE;IACpD,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,eAAc;;;;IAInC,GAAG,oBAAoB,CAAC;MACtB,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,WAAW,EAAC;KAC/C;IACD,OAAO,MAAM;GACd;;;EAGD,WAAW,EAAE;IACX,OAAO,IAAI,CAAC,cAAc,CAAC,QAAQ;GACpC;;;EAGD,mBAAmB,EAAE;IACnB,OAAO,IAAI,CAAC,cAAc,CAAC,gBAAgB,EAAE;GAC9C;;;EAGD,aAAa,EAAE;IACb,OAAO,IAAI,CAAC,cAAc,CAAC,UAAU;GACtC;;;EAGD,IAAI,EAAE;IACJ,IAAI,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAC;IACpC,MAAM,CAAC,KAAK,CAAC,CAAC,oCAAmC;GAClD;;CAEF;;ACxCD,MAAM,eAAe,CAAC;;EAEpB,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC;IAC5B,GAAG,CAAC,YAAY,CAAC;MACf,IAAI,CAAC,aAAa,GAAG,IAAI,YAAY,GAAE;KACxC,MAAM;MACL,IAAI,CAAC,aAAa,GAAG,aAAY;KAClC;;IAED,IAAI,CAAC,WAAW,GAAG,GAAE;GACtB;;;EAGD,WAAW,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC;IAC1B,IAAI,aAAa,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC,KAAI;IAC3C,IAAI,IAAI,GAAG,KAAI;IACf,IAAI,UAAU,GAAG,IAAI,UAAU,GAAE;;IAEjC,UAAU,CAAC,MAAM,GAAG,SAAS,CAAC,CAAC;MAC7B,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM;;;QAGhD,SAAS,kBAAkB,EAAE;UAC3B,IAAI,CAAC,SAAS,CAAC,kBAAkB,EAAE,aAAa,EAAE,IAAI,CAAC,aAAa,EAAC;SACtE;;;QAGD,SAAS,CAAC,CAAC;UACT,OAAO,CAAC,GAAG,CAAC,gCAAgC,GAAG,CAAC,CAAC,GAAG,EAAC;SACtD,EAAC;MACL;IACD,UAAU,CAAC,iBAAiB,CAAC,IAAI,EAAC;GACnC;;;EAGD,SAAS,CAAC,kBAAkB,EAAE,IAAI,EAAE,YAAY,CAAC;IAC/C,GAAG,IAAI,IAAI,IAAI,CAAC,WAAW,CAAC;MAC1B,MAAM,IAAI,KAAK,CAAC,CAAC,cAAc,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;KACzD;;IAED,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,IAAI,KAAK,CAAC,IAAI,EAAE,kBAAkB,EAAE,YAAY,EAAC;GAC3E;;CAEF;;AC3CD,YAAe,CAAC;EACd,eAAe;CAChB,CAAC;;;;"}